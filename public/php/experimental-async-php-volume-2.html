<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<title>Experimental async PHP - Volume 2 | Holger Woltersdorf&#039;s blog</title>
	<meta name="description" content="Second try to run a PHP daemon receiving messages from RabbtiMQ and executing commands async on the php-fpm socket">
	<meta name="keywords" content="PHP, async, php-fpm, RabbitMQ, send, receive, producer, experimental, daemon, worker, socket">
	<meta name="HandheldFriendly" content="True"/>
	<meta name="geo.region" content="DE-SN"/>
	<meta name="geo.placename" content="Dresden"/>
	<meta name="geo.position" content="51.052088;13.741672"/>
	<meta name="ICBM" content="51.052088, 13.741672"/>
	<meta name="twitter:site" content="@hollodotme">
	<meta name="twitter:creator" content="@hollodotme">
	<script type="application/ld+json">{
  "@context" : "http://schema.org",
  "@type": "Person",
  "name": "Holger Woltersdorf&#039;s blog",
  "image": "http://127.0.0.1:8081/img/posts/caller-rabbitmq-daemon-socket-worker.png",
  "url": "http://127.0.0.1:8081",
  "sameAs" : [
      "https://twitter.com/hollodotme",
      "https://www.xing.com/profile/Holger_Woltersdorf"
    ]
  }
}</script>
	<meta property="article:author" content="https://www.xing.com/profile/Holger_Woltersdorf"/>
	<meta property="article:publisher" content="https://www.xing.com/profile/Holger_Woltersdorf"/>
	<link rel="apple-touch-icon" sizes="57x57" href="/favicon/apple-icon-57x57.png">
	<link rel="apple-touch-icon" sizes="60x60" href="/favicon/apple-icon-60x60.png">
	<link rel="apple-touch-icon" sizes="72x72" href="/favicon/apple-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="76x76" href="/favicon/apple-icon-76x76.png">
	<link rel="apple-touch-icon" sizes="114x114" href="/favicon/apple-icon-114x114.png">
	<link rel="apple-touch-icon" sizes="120x120" href="/favicon/apple-icon-120x120.png">
	<link rel="apple-touch-icon" sizes="144x144" href="/favicon/apple-icon-144x144.png">
	<link rel="apple-touch-icon" sizes="152x152" href="/favicon/apple-icon-152x152.png">
	<link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-icon-180x180.png">
	<link rel="icon" type="image/png" sizes="192x192" href="/favicon/android-icon-192x192.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="96x96" href="/favicon/favicon-96x96.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
	<link rel="manifest" href="/favicon/manifest.json">
	<meta name="msapplication-TileColor" content="#ffffff">
	<meta name="msapplication-TileImage" content="/favicon/ms-icon-144x144.png">
	<meta name="theme-color" content="#ffffff">

	<link rel="canonical" href="http://127.0.0.1:8081/php/experimental-async-php-volume-2.html"/>
	<meta name="referrer" content="origin"/>

	<meta property="og:site_name" content="Holger Woltersdorf&#039;s blog"/>
	<meta property="og:type" content="article"/>
	<meta property="og:title" content="Experimental async PHP - Volume 2 | Holger Woltersdorf&#039;s blog"/>
	<meta property="og:description" content="Second try to run a PHP daemon receiving messages from RabbtiMQ and executing commands async on the php-fpm socket"/>
	<meta property="og:url" content="http://127.0.0.1:8081"/>
	<meta property="og:image" content="http://127.0.0.1:8081/img/posts/caller-rabbitmq-daemon-socket-worker.png"/>
	<meta property="article:published_time" content="2019-04-22T11:49:33+00:00"/>
	<meta property="article:modified_time" content="2019-04-22T11:49:33+00:00"/>
			<meta property="article:tag" content="PHP"/>
			<meta property="article:tag" content="async"/>
			<meta property="article:tag" content="php-fpm"/>
			<meta property="article:tag" content="RabbitMQ"/>
			<meta property="article:tag" content="send"/>
			<meta property="article:tag" content="receive"/>
			<meta property="article:tag" content="producer"/>
			<meta property="article:tag" content="experimental"/>
			<meta property="article:tag" content="daemon"/>
			<meta property="article:tag" content="worker"/>
			<meta property="article:tag" content="socket"/>
		<meta name="twitter:card" content="summary_large_image"/>
	<meta name="twitter:title" content="Experimental async PHP - Volume 2 | Holger Woltersdorf&#039;s blog"/>
	<meta name="twitter:description" content="Second try to run a PHP daemon receiving messages from RabbtiMQ and executing commands async on the php-fpm socket"/>
	<meta name="twitter:url" content="http://127.0.0.1:8081/php/experimental-async-php-volume-2.html"/>
	<meta name="twitter:image:src" content="http://127.0.0.1:8081/img/posts/caller-rabbitmq-daemon-socket-worker.png"/>

	<meta name="generator" content="IceHawk Static Page Generator"/>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">

	<link href="https://fonts.googleapis.com/css?family=Oxygen|Oxygen+Mono" rel="stylesheet">
	<link rel="stylesheet" type="text/css" media="screen" href="http://127.0.0.1:8081/css/theme.css">
	<script src="https://use.fontawesome.com/3513f09ab7.js"></script>
	</head>
<body>
<div class="themewrapper">

	<a href="#" id="sidebar-toggle"><i class="fa fa-close genericon"></i></a>

	<div id="sidebar">
		<div class="brand-well">
			<a href="http://127.0.0.1:8081">
				<img src="http://127.0.0.1:8081/img/hwoltersdorf_blue_500x500.png" alt="Holger Woltersdorf">
			</a>
		</div>

		<h3 class="text-center text-uppercase">Holger Woltersdorf</h3>
		<p class="text-center text-uppercase subline">
			CIO &middot; Developer &middot; Speaker<br>
			PHP &middot; WEB &middot; Community
		</p>

		<hr>

		<ul class="sociallinks">
			<li>
				<a href="https://twitter.com/hollodotme" title="Holger Woltersdorf on twitter (@hollodotme)" target="_blank"><i class="fa fa-twitter"></i></a>
			</li>
			<li>
				<a href="https://www.xing.com/profile/Holger_Woltersdorf" title="Holger Woltersdorf on Xing" target="_blank"><i class="fa fa-xing"></i></a>
			</li>
			<li>
				<a href="https://github.com/hollodotme" title="Holger Woltersdorf on GitHub" target="_blank"><i class="fa fa-github"></i></a>
			</li>
			<li>
				<a href="https://www.linkedin.com/in/holgerwoltersdorf" title="Holger Woltersdorf on LinkedIn" target="_blank"><i class="fa fa-linkedin"></i></a>
			</li>
		</ul>

		<hr>

		<ul class="sidebar-nav">
			<li class="hidden-sm hidden-md hidden-lg">
				<a href="http://127.0.0.1:8081/" title="Home">Home</a>
			</li>
			
						<li class="active">
		<a href="http://127.0.0.1:8081/php.html">PHP</a>
			</li>


			
						<li>
		<a href="http://127.0.0.1:8081/talks.html">Talks</a>
			</li>


			
						<li>
		<a href="http://127.0.0.1:8081/projects.html">Projects</a>
			</li>


			
						<li>
		<a href="http://127.0.0.1:8081/devops.html">DevOps</a>
			</li>


			
						<li>
		<a href="http://127.0.0.1:8081/reading-list.html">Reading list</a>
			</li>


			
						<li>
		<a href="http://127.0.0.1:8081/imprint.html">Imprint</a>
			</li>


						<li>
				<a href="https://www.papercall.io/speakers/hollodotme" target="_blank" title="My profile on papercall.io">
					PaperCall.io profile
				</a>
			</li>
			<li>
				<a href="https://speakerdeck.com/hollodotme" target="_blank" title="My profile on speakerdeck.com">
					SpeakerDeck profile
				</a>
			</li>
		</ul>

		<hr>

		<div class="text-center">
			<p>
				<small>Co-Founder of</small>
			</p>
			<a href="http://phpug-dresden.org" target="_blank">
				<img src="http://127.0.0.1:8081/img/php-usergroup-dresden.png" alt="PHP USERGROUP DRESDEN e.V." class="img img-50">
			</a>
		</div>

		<hr>

		<p class="text-center">
			<strong>Found a bug or a typo?</strong><br>
			This website is open source,<br>
			<a href="https://github.com/hollodotme/hollo.me" target="_blank" title="Website GitHub repository">please fork it and provide a PR</a>.
		</p>
		<p class="text-center website-version">
			<small>v1.2.1</small>
		</p>

	</div>

	<div id="breadcrumbs">
		<ul>
												<li>
						<a href="http://127.0.0.1:8081/index.html">
							<i class="fa fa-map-marker"></i> Home
						</a>
					</li>
																<li>
						<a href="http://127.0.0.1:8081/php.html">
							 PHP
						</a>
					</li>
																<li class="active">
						 Experimental async PHP - VOL. 2
					</li>
									</ul>
	</div>

	<div id="main">

		
			<h1>Experimental async PHP - Volume 2</h1>
			<h5>Second try to run a PHP daemon receiving messages from RabbtiMQ and executing commands async on the php-fpm socket</h5>
			<hr>

			<h2>Updates</h2>
<ul>
<li>2017-03-07: Code updated for <a href="https://github.com/hollodotme/fast-cgi-client/tree/v2.1.0">v2.1.0 of hollodotme/fast-cgi-client</a>.</li>
<li>2017-09-11: Q&amp;A: <a href="http://127.0.0.1:8081/php/experimental-async-php-volume-2-error-handling.html">Error handling and retry</a></li>
<li>2017-09-17: Q&amp;A: <a href="http://127.0.0.1:8081/php/experimental-async-php-volume-2-parallelism.html">Parallelism</a></li>
</ul>
<hr />
<h2>Preamble</h2>
<p>Taking the topic of my <a href="http://127.0.0.1:8081/php/experimental-async-php-volume-1.html">previous post</a> further, it is time to (hopefully) eliminate some drawbacks
that came along in the first try, such as:</p>
<ul>
<li>Redis has no message backlog. If the &quot;Daemon&quot; is not running for any reason, published messages will never be received.</li>
<li>Redis has a <a href="https://redis.io/commands/publish">publishing complexity</a> of &quot;<code>O(N+M)</code> where N is the number of clients subscribed to the receiving channel and M is the total number of subscribed patterns (by any client).&quot;
So all &quot;Daemons&quot; (if multiple) would get the same messages and trigger the same &quot;Workers&quot;. </li>
</ul>
<p>So let's change the goal a bit and replace Redis with a real message broker: <a href="https://www.rabbitmq.com">RabbitMQ</a>.</p>
<h2>Goal</h2>
<ul>
<li>A PHP script (&quot;Caller&quot;) sending messages to the RabbitMQ message queue system (&quot;Broker&quot;)</li>
<li>A PHP script (&quot;Daemon&quot;) running as a proper daemon consuming messages from the queue </li>
<li>On consuming a message the &quot;Daemon&quot; sends a new async request through php-fpm socket to the &quot;Worker&quot;</li>
<li>The php-fpm socket serves as an &quot;isolated&quot; pool and spawns child processes</li>
<li>The &quot;Workers&quot; process the requests in background </li>
</ul>
<p><span class="img center">
<a href="http://127.0.0.1:8081/img/posts/caller-rabbitmq-daemon-socket-worker.png"><img src="http://127.0.0.1:8081/img/posts/caller-rabbitmq-daemon-socket-worker.png" alt="Caller-RabbitMQ-Daemon-Socket-Worker" /></a>
</span></p>
<hr />
<h2>Used environment</h2>
<ul>
<li>OS: Ubuntu Xenial 16.04.1 LTS</li>
<li>PHP 7.1.0-3+deb.sury.org~xenial+1</li>
<li><a href="https://www.rabbitmq.com/install-debian.html">RabbitMQ Server 3.6.6</a></li>
<li><a href="https://getcomposer.org">composer PHP dependency manager</a></li>
<li><i class="fa fa-github"></i> <a href="https://github.com/hollodotme/fast-cgi-client">hollodotme/fast-cgi-client</a></li>
<li><i class="fa fa-github"></i> <a href="https://github.com/php-amqplib/php-amqplib">php-amqplib/php-amqplib</a></li>
</ul>
<hr />
<h2>The &quot;Caller&quot; version #1</h2>
<p>Again, the &quot;Caller&quot; is a simple script, that sends a message to the &quot;Broker&quot;, to a queue named &quot;commands&quot;.
To be a little more verbose we'll provide a counter as an argument to the script that will be the content of the message.</p>
<p><i class="fa fa-file-o"></i> <code>src/caller.php</code></p>
<pre><code class="language-php">&lt;?php declare(strict_types = 1);

namespace hollodotme\AsyncPhp;

require(__DIR__ . '/../vendor/autoload.php');

use PhpAmqpLib\Connection\AMQPStreamConnection;
use PhpAmqpLib\Message\AMQPMessage;

# Connect and retrieve a channel
$connection = new AMQPStreamConnection( 'localhost', 5672, 'guest', 'guest' );
$channel    = $connection-&gt;channel();

# Make sure the queue 'commands' exist
$channel-&gt;queue_declare( 'commands' );

# Create and send the message
$message = new AMQPMessage( json_encode( [ 'number' =&gt; $argv[1] ], JSON_PRETTY_PRINT ) );
$channel-&gt;basic_publish( $message, '', 'commands' );

echo " [x] Message sent: {$argv[1]}\n";

# Close channel and connection
$channel-&gt;close();
$connection-&gt;close();</code></pre>
<hr />
<h2>The &quot;Daemon&quot; version #1</h2>
<p>Also in the &quot;Daemon&quot; we replace the Redis subscription with a basic consumption of messages sent to the &quot;commands&quot; queue of the &quot;Broker&quot;.</p>
<p>When a message is consumed a callback function (Closure) will be invoked.
This Closure will again send a request to our previously set up php-fpm pool, thus to our &quot;Workers&quot;.</p>
<p><i class="fa fa-file-o"></i> <code>src/daemon.php</code></p>
<pre><code class="language-php">&lt;?php declare(strict_types = 1);

namespace hollodotme\AsyncPhp;

use hollodotme\FastCGI\Client;
use hollodotme\FastCGI\Requests\PostRequest;
use hollodotme\FastCGI\SocketConnections\UnixDomainSocket;
use PhpAmqpLib\Connection\AMQPStreamConnection;
use PhpAmqpLib\Message\AMQPMessage;

require(__DIR__ . '/../vendor/autoload.php');

# Connect to the same RabbitMP instance and get a channel
$connection = new AMQPStreamConnection( 'localhost', 5672, 'guest', 'guest' );
$channel    = $connection-&gt;channel();

# Make sure the queue "commands" exists
$channel-&gt;queue_declare( 'commands' );

# Prepare the Fast CGI Client
$unixDomainSocket = new UnixDomainSocket( 'unix:///var/run/php/php7.1-fpm-commands.sock' );

# Define a callback function that is invoked whenever a message is consumed
$callback = function ( AMQPMessage $message ) use ( $unixDomainSocket )
{
    # Decode the json message and encode it for sending to php-fpm
    $messageArray = json_decode( $message-&gt;getBody(), true );
    $body         = http_build_query( $messageArray );

    # Send an async request to php-fpm pool and receive a process ID
    $fpmClient = new Client( $unixDomainSocket );

    $request = new PostRequest( '/vagrant/src/worker.php', $body );

    $processId = $fpmClient-&gt;sendAsyncRequest( $request );

    echo " [x] Spawned process with ID {$processId} for message number {$messageArray['number']}\n";
};

# Request consumption for queue "commands" using the defined callback function
$channel-&gt;basic_consume( 'commands', '', false, true, false, false, $callback );

# Wait to finish execution as long as the channel has callbacks
while ( count( $channel-&gt;callbacks ) )
{
    $channel-&gt;wait();
}</code></pre>
<p><strong>Note:</strong> You should not a use a persistent socket connection to php-fpm here, since you'll receive notices like this once in a while:
<code>PHP Notice:  fwrite(): send of 399 bytes failed with errno=11 Resource temporarily unavailable ...</code>. And a persistent connection will also cause the
php-fpm pool to spawn only one child worker, instead of as much as needed / configured. </p>
<hr />
<h2>The &quot;Worker&quot;</h2>
<p>The worker remains the same for now. It simply logs the received number to a log file and sleeps for one second.</p>
<p><i class="fa fa-file-o"></i> <code>src/worker.php</code></p>
<pre><code class="language-php">&lt;?php declare(strict_types = 1);

namespace hollodotme\AsyncPhp;

require(__DIR__ . '/../vendor/autoload.php');

error_log( "Processing {$_POST['number']}\n", 3, sys_get_temp_dir() . '/workers.log' );

sleep( 1 );</code></pre>
<hr />
<h2>First test</h2>
<ol>
<li>(Re)start the &quot;Daemon&quot; and check if it's running properly:
<pre><code class="language-bash">sudo service php-daemon restart &amp;&amp; sudo service php-daemon status</code></pre></li>
<li>Watch the process list for spawning <code>php-fpm pool commands</code> (in a new terminal tab):
<pre><code class="language-bash">watch -n1 "sudo ps aux | grep 'php-fpm: pool commands' | grep -v grep"</code></pre></li>
<li>Watch the <code>logs/worker.log</code> (in a new terminal tab):
<pre><code class="language-bash">tailf "cat /tmp/workers.log"</code></pre></li>
<li>Watch the syslog for spawned process by &quot;Daemon&quot; (in a new terminal tab):
<pre><code class="language-bash">tailf /var/log/syslog | grep '\[x\]'</code></pre></li>
<li>Execute the &quot;Caller&quot; 100 times:
<pre><code class="language-bash">for i in $(seq 1 100); do php7.1 src/caller.php $i; done</code></pre></li>
</ol>
<p><strong>Results:</strong></p>
<ul>
<li>Top-left: Loop sending 100 messages sequentially (via <code>src/caller.php</code>)</li>
<li>Top-right: Current process list showing the spawning and dying children in php-fpm pool &quot;commands&quot;</li>
<li>Bottom-left: The log file all &quot;Workers&quot; write their received requests to (<code>src/worker.php</code>)</li>
<li>Bottom-right: Syslog showing all async requests to php-fpm (via <code>src/daemon.php</code>)</li>
</ul>
<video width="100%" controls>
  <source src="http://127.0.0.1:8081/video/php/ExperimentalAsyncPHPvol2-1.mp4" type="video/mp4">
Your browser does not support the video tag.
</source></video>
<hr />
<p>This result is already pretty much what we want, but there are still some &quot;hidden&quot; drawbacks:</p>
<ol>
<li>
<p><strong>The message queue consumption</strong><br />
While the test above runs, a glimpse at the RabbitMQ queue list (<code>rabbitmqctl list_queues</code>) shows that there is a queue named &quot;commands&quot; with &quot;0&quot; outstanding messages.
This is because our messages are not persistent and are immediately delivered to the consumer, that connects first.
This is not what we want if we want to scale to multiple &quot;Daemons&quot;. Currently there is no &quot;distribution plan&quot; for messages for multiple &quot;Daemons&quot;.  </p>
</li>
<li><strong>&quot;Daemons&quot; gonna die!</strong><br />
Occasionally consumers of messages happen to die for whatever reason. Since our messages are not persistent yet, they will be deleted from the
queue as soon as they were sent to the &quot;Daemon&quot;, regardless if they were fully processed or not.</li>
</ol>
<hr />
<h2>Persist and acknowledge</h2>
<p>To eliminate the before mentioned drawbacks we should slightly change the usage of RabbitMQ to have work queues (task queues) with persistent messages
instead of volatile messages. So if messages are persistent, we also need to tell the channel when a message (task) was fully processed and can be deleted from the queue.
Thus we'll send an acknowledgement back to the channel.</p>
<h3>The &quot;Caller&quot; version #2</h3>
<p><i class="fa fa-file-o"></i> <code>src/caller.php</code></p>
<pre><code class="language-php">&lt;?php declare(strict_types = 1);

namespace hollodotme\AsyncPhp;

require(__DIR__ . '/../vendor/autoload.php');

use PhpAmqpLib\Connection\AMQPStreamConnection;
use PhpAmqpLib\Message\AMQPMessage;

# Connect and retrieve a channel
$connection = new AMQPStreamConnection( 'localhost', 5672, 'guest', 'guest' );
$channel    = $connection-&gt;channel();

# Make sure the queue 'commands' exist
# Make the queue persistent (set 3rd parameter to true)
$channel-&gt;queue_declare( 'commands', false, true );

$payload = json_encode( [ 'number' =&gt; $argv[1] ], JSON_PRETTY_PRINT );

# Create and send the message
$message = new AMQPMessage(
    $payload,
    [
        # Make message persistent
        'delivery_mode' =&gt; AMQPMessage::DELIVERY_MODE_PERSISTENT,
    ]
);

$channel-&gt;basic_publish( $message, '', 'commands' );

echo " [x] Message sent: {$argv[1]}\n";

# Close channel and connection
$channel-&gt;close();
$connection-&gt;close();</code></pre>
<p><strong>What has changed?</strong></p>
<ul>
<li>
<p>The &quot;commands&quot; queue was declared to be persistent (durable). This ensures that even if the RabbitMQ server dies the messages won't be lost.  </p>
<pre><code class="language-php">$channel-&gt;queue_declare( 'commands', false, true ); # Third parameter set to true</code></pre>
</li>
<li>The message was declared to be persistent (durable). This gives us the ability to acknowledge when a message was processed and if it was not fully
processed it enables RabbitMQ to re-route the message to another consumer, if there is one.  
<pre><code class="language-php">$message = new AMQPMessage(
    $payload,
    [
        # Make message persistent
        'delivery_mode' =&gt; AMQPMessage::DELIVERY_MODE_PERSISTENT,
    ]
);</code></pre></li>
</ul>
<hr />
<p><a name="daemon-version-2"></a></p>
<h3>The &quot;Daemon&quot; version #2</h3>
<p><i class="fa fa-file-o"></i> <code>src/daemon.php</code></p>
<pre><code class="language-php">&lt;?php declare(strict_types = 1);

namespace hollodotme\AsyncPhp;

use hollodotme\FastCGI\Client;
use hollodotme\FastCGI\Requests\PostRequest;
use hollodotme\FastCGI\SocketConnections\UnixDomainSocket;
use PhpAmqpLib\Connection\AMQPStreamConnection;
use PhpAmqpLib\Message\AMQPMessage;

require(__DIR__ . '/../vendor/autoload.php');

# Connect to the same RabbitMP instance and get a channel
$connection = new AMQPStreamConnection( 'localhost', 5672, 'guest', 'guest' );
$channel    = $connection-&gt;channel();

# Make sure the queue "commands" exists
# Make the queue persistent (set 3rd parameter to true)
$channel-&gt;queue_declare( 'commands', false, true );

# Prepare the Fast CGI Client
$unixDomainSocket = new UnixDomainSocket( 'unix:///var/run/php/php7.1-fpm-commands.sock' );

$daemonId = sprintf( 'D-%03d', mt_rand( 1, 100 ) );

# Define a callback function that is invoked whenever a message is consumed
$callback = function ( AMQPMessage $message ) use ( $unixDomainSocket, $daemonId )
{
    # Decode the json message and encode it for sending to php-fpm
    $messageArray             = json_decode( $message-&gt;getBody(), true );
    $messageArray['daemonId'] = $daemonId;
    $body                     = http_build_query( $messageArray );

    # Send an async request to php-fpm pool and receive a process ID
    $fpmClient = new Client( $unixDomainSocket );

    $request = new PostRequest( '/vagrant/src/worker.php', $body );

    $processId = $fpmClient-&gt;sendAsyncRequest($request);

    echo " [x] Spawned process with ID {$processId} for message number {$messageArray['number']}\n";

    # Send the ACK(nowledgement) back to the channel for this particular message
    $message-&gt;get( 'channel' )-&gt;basic_ack( $message-&gt;get( 'delivery_tag' ) );
};

# Set the prefetch count to 1 for this consumer
$channel-&gt;basic_qos( null, 1, null );

# Request consumption for queue "commands" using the defined callback function
# Enable message acknowledgement (set 4th parameter to false)
$channel-&gt;basic_consume( 'commands', '', false, false, false, false, $callback );

# Wait to finish execution as long as the channel has callbacks
while ( count( $channel-&gt;callbacks ) )
{
    $channel-&gt;wait();
}</code></pre>
<p><strong>What has changed?</strong></p>
<ul>
<li>
<p>Just like in the &quot;Caller&quot;, the &quot;commands&quot; queue was declared to be persistent (durable). This ensures that even if the RabbitMQ server dies the messages won't be lost.  </p>
<pre><code class="language-php">$channel-&gt;queue_declare( 'commands', false, true ); # Third parameter set to true</code></pre>
</li>
<li>
<p>For the next test, where we will simulate a second &quot;Daemon&quot;, a random <code>$daemonId</code> was added and set in the request array. So we later can see which &quot;Daemon&quot; processed which messages.  </p>
<pre><code class="language-php">$daemonId = sprintf( 'D-%03d', mt_rand( 1, 100 ) );
# ...
$callback = function ( AMQPMessage $message ) use ( $unixDomainSocket, $daemonId )
# ...
$messageArray['daemonId'] = $daemonId;</code></pre>
</li>
<li>
<p>We set the <a href="http://www.rabbitmq.com/consumer-prefetch.html">prefetch count</a> for this consumer to <code>1</code>. That means the &quot;Daemon&quot; will only accept one
message at a time and leave the rest in the queue until the message was processed and acknowledged. So RabbitMQ can distribute the remained messages to another &quot;Daemon&quot;, if there is one.</p>
<pre><code class="language-php">$channel-&gt;basic_qos( null, 1, null );</code></pre>
</li>
<li>
<p>We enabled message acknowledgement:</p>
<pre><code class="language-php"># 4th parameter set to false
$channel-&gt;basic_consume( 'commands', '', false, false, false, false, $callback );</code></pre>
</li>
<li>We send an ACK(nowledge) back to the channel as soon as we spawned our &quot;Worker&quot;:
<pre><code class="language-php">$message-&gt;get( 'channel' )-&gt;basic_ack( $message-&gt;get( 'delivery_tag' ) );</code></pre></li>
</ul>
<p>Make sure to restart the &quot;Daemon&quot; after these changes, otherwise the queue won't be persistent.</p>
<hr />
<h3>The &quot;Worker&quot; version #2</h3>
<p><i class="fa fa-file-o"></i> <code>src/worker.php</code></p>
<pre><code class="language-php">&lt;?php declare(strict_types = 1);

namespace hollodotme\AsyncPhp;

require(__DIR__ . '/../vendor/autoload.php');

error_log(
    " [x] Processing {$_POST['number']} from daemon {$_POST['daemonId']}\n",
    3,
    sys_get_temp_dir() . '/workers.log'
);

sleep( 1 );</code></pre>
<p><strong>What has changed?</strong></p>
<ul>
<li>The log message was extended with the daemon ID.  
<pre><code class="language-php">" [x] Processing {$_POST['number']} from daemon {$_POST['daemonId']}\n",</code></pre></li>
</ul>
<hr />
<h2>Second test</h2>
<p>In this test we will...</p>
<ul>
<li>
<p>start the previous loop that executes <code>src/caller.php</code> 3 times in parallel, just to simulate some traffic.  </p>
<pre><code class="language-bash">for i in 1 2 3; do for j in $(seq 1 100); do php7.1 src/caller.php $j; done &amp; done</code></pre>
</li>
<li>
<p>increase the count of max children in php-fpm pool &quot;commands&quot; to 25 (<code>/etc/php/7.1/fpm/pool.d/commands.conf</code>):</p>
<pre><code class="language-ini">pm.max_children = 25</code></pre>
</li>
<li>manually start a second &quot;Daemon&quot; to test if messages will be distributed to both running daemons.</li>
</ul>
<p><strong>Results:</strong></p>
<ul>
<li>Top-left: Loops sending messages to RabbtMQ (<code>src/caller.php</code>)</li>
<li>Top-middle: Output of our first &quot;Daemon&quot; running via <code>systemd</code> </li>
<li>Top-right: The second &quot;Daemon&quot; that is started during the test (<code>src/daemon.php</code>)</li>
<li>Bottom-left: The current process list for php-fpm children in pool &quot;commands&quot;</li>
<li>Bottom-middle: Output of the <code>/tmp/workers.log</code> written by all async workers (<code>src/worker.php</code>)<br />
<strong>NOTE:</strong> After the second daemon was started you can see a second daemon ID in the logs. </li>
<li>Bottom-right: Queue list of RabbitMQ incl. count for messages ready and messages unacknowledged  
<pre><code class="language-bash">sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged</code></pre></li>
</ul>
<video width="100%" controls>
  <source src="http://127.0.0.1:8081/video/php/ExperimentalAsyncPHPvol2-2.mp4" type="video/mp4">
Your browser does not support the video tag.
</source></video>
<hr />
<h2>Summary</h2>
<ul>
<li>
<p>We replaced the mostly synchronous Redis PubSub system with the real async message broker RabbitMQ and established a persistent work queue able
to distribute messages to multiple consumers.</p>
</li>
<li>
<p>We simulated a little scaling by switching a second daemon (consumer) on and off. You can play with variants and settings of the test described above.
I did and it simply worked in all cases with of course differing performance, but no messages were lost during the tests and that is what matters.</p>
</li>
<li>
<p>This is by far a way better solution than the first try and it seems quite stable. But...<br />
Doing the code was a bit messy, because the <code>php-amqplib</code> is poorly documented and the object API is not very self-explanatory with a lot of boolean flags.
The <a href="https://www.rabbitmq.com/tutorials/tutorial-one-php.html">official RabbitMQ PHP tutorials</a> helped, but are a little outdated too.</p>
</li>
<li>In the end, I think it is a slim setup with a lot of potential.
<ul>
<li>127 lines of PHP code</li>
<li>2 composer dependencies (no subsequent dependencies)</li>
<li>2 config files (for systemd and php-fpm)</li>
<li>1 deb install (rabbitmq-server)</li>
</ul></li>
</ul>
<p>The next step will be a real-world implementation and further testing.</p>
<p>You can find the example code of this blog post here <i class="fa fa-github"></i> <a href="https://github.com/hollodotme/experimental-async-php-vol2">hollodotme/experimental-async-php-vol2</a></p>
<p>I hope you liked that post.
If you're in the mood to give me feedback, <a href="https://twitter.com/hollodotme">tweet me a tweet</a>
or <a href="https://github.com/hollodotme/experimental-async-php-vol2/issues">open a discussion on GitHub</a>. </p>
<p>Thank you.</p>
<hr />
<p>[<i class="fa fa-coffee"></i><i class="fa fa-coffee"></i><i class="fa fa-coffee"></i><i class="fa fa-coffee"></i><i class="fa fa-coffee"></i>░░░░░░░░░░░░░░░░░░<i class="fa fa-beer"></i>] 2 days | <small>01/11/2017</small></p>

		
	</div>
</div>
<script src="http://127.0.0.1:8081/js/theme.js"></script>
<script src="http://127.0.0.1:8081/js/prism.js"></script>
<link rel="stylesheet" href="http://127.0.0.1:8081/css/prism.css">
</body>
</html>
