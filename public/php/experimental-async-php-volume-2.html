<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<title>Experimental async PHP - Volume 2 | Holger Woltersdorf&#039;s blog</title>
	<meta name="description" content="Coming Soon">
	<meta name="keywords" content="PHP, async, php-fpm, RabbitMQ, send, receive, producer, experimental, daemon, worker, socket">
	<meta name="HandheldFriendly" content="True"/>
	<meta name="geo.region" content="DE-SN"/>
	<meta name="geo.placename" content="Dresden"/>
	<meta name="geo.position" content="51.052088;13.741672"/>
	<meta name="ICBM" content="51.052088, 13.741672"/>
	<meta name="twitter:site" content="@hollodotme">
	<meta name="twitter:creator" content="@hollodotme">
	<script type="application/ld+json">{
  "@context" : "http://schema.org",
  "@type": "Person",
  "name": "Holger Woltersdorf&#039;s blog",
  "image": "https://hollo.me/img/posts/caller-redis-daemon-socket-worker.png",
  "url": "https://hollo.me",
  "sameAs" : [
      "https://twitter.com/hollodotme",
      "https://www.xing.com/profile/HolgerWoltersdorf"
    ]
  }
}</script>
	<meta property="article:author" content="https://www.xing.com/profile/HolgerWoltersdorf"/>
	<meta property="article:publisher" content="https://www.xing.com/profile/HolgerWoltersdorf"/>
	<link rel="apple-touch-icon" sizes="57x57" href="/favicon/apple-icon-57x57.png">
	<link rel="apple-touch-icon" sizes="60x60" href="/favicon/apple-icon-60x60.png">
	<link rel="apple-touch-icon" sizes="72x72" href="/favicon/apple-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="76x76" href="/favicon/apple-icon-76x76.png">
	<link rel="apple-touch-icon" sizes="114x114" href="/favicon/apple-icon-114x114.png">
	<link rel="apple-touch-icon" sizes="120x120" href="/favicon/apple-icon-120x120.png">
	<link rel="apple-touch-icon" sizes="144x144" href="/favicon/apple-icon-144x144.png">
	<link rel="apple-touch-icon" sizes="152x152" href="/favicon/apple-icon-152x152.png">
	<link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-icon-180x180.png">
	<link rel="icon" type="image/png" sizes="192x192" href="/favicon/android-icon-192x192.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="96x96" href="/favicon/favicon-96x96.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
	<link rel="manifest" href="/favicon/manifest.json">
	<meta name="msapplication-TileColor" content="#ffffff">
	<meta name="msapplication-TileImage" content="/favicon/ms-icon-144x144.png">
	<meta name="theme-color" content="#ffffff">

	<link rel="canonical" href="https://hollo.me/php/experimental-async-php-volume-2.html"/>
	<meta name="referrer" content="origin"/>

	<meta property="og:site_name" content="Holger Woltersdorf&#039;s blog"/>
	<meta property="og:type" content="article"/>
	<meta property="og:title" content="Experimental async PHP - Volume 2 | Holger Woltersdorf&#039;s blog"/>
	<meta property="og:description" content="Second try to run a PHP daemon receiving messages from RabbtiMQ and executing commands async on the php-fpm socket"/>
	<meta property="og:url" content="https://hollo.me"/>
	<meta property="og:image" content="https://hollo.me/img/posts/caller-redis-daemon-socket-worker.png"/>
	<meta property="article:published_time" content="2017-01-10T00:48:08+01:00"/>
	<meta property="article:modified_time" content="2017-01-10T00:48:08+01:00"/>
			<meta property="article:tag" content="PHP"/>
			<meta property="article:tag" content="async"/>
			<meta property="article:tag" content="php-fpm"/>
			<meta property="article:tag" content="RabbitMQ"/>
			<meta property="article:tag" content="send"/>
			<meta property="article:tag" content="receive"/>
			<meta property="article:tag" content="producer"/>
			<meta property="article:tag" content="experimental"/>
			<meta property="article:tag" content="daemon"/>
			<meta property="article:tag" content="worker"/>
			<meta property="article:tag" content="socket"/>
		<meta name="twitter:card" content="summary_large_image"/>
	<meta name="twitter:title" content="Experimental async PHP - Volume 2 | Holger Woltersdorf&#039;s blog"/>
	<meta name="twitter:description" content="Second try to run a PHP daemon receiving messages from RabbtiMQ and executing commands async on the php-fpm socket"/>
	<meta name="twitter:url" content="https://hollo.me/php/experimental-async-php-volume-2.html"/>
	<meta name="twitter:image:src" content="https://hollo.me/img/posts/caller-redis-daemon-socket-worker.png"/>

	<meta name="generator" content="IceHawk Static Page Generator"/>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">

	<link rel="stylesheet" type="text/css" media="screen" href="https://hollo.me/css/theme.css">
	<script src="https://use.fontawesome.com/3513f09ab7.js"></script>
	</head>
<body>
<div class="themewrapper">

	<a href="#" id="sidebar-toggle"><i class="fa fa-close genericon"></i></a>

	<div id="sidebar">
		<div class="brand-well">
			<a href="https://hollo.me">
				<img src="https://hollo.me/img/Profile.png" alt="Holger Woltersdorf">
			</a>
		</div>

		<h3 class="text-center text-uppercase">Holger Woltersdorf</h3>
		<p class="text-center text-uppercase subline">
			CIO &middot; Developer &middot; Speaker<br>
			PHP &middot; WEB &middot; Markdown lover
		</p>

		<hr>

		<ul class="sociallinks">
			<li>
				<a href="https://twitter.com/hollodotme" title="Holger Woltersdorf on twitter (@hollodotme)" target="_blank"><i class="fa fa-twitter"></i></a>
			</li>
			<li>
				<a href="https://www.xing.com/profile/HolgerWoltersdorf" title="Holger Woltersdorf on Xing" target="_blank"><i class="fa fa-xing"></i></a>
			</li>
			<li>
				<a href="https://github.com/hollodotme" title="Holger Woltersdorf on GitHub" target="_blank"><i class="fa fa-github"></i></a>
			</li>
			<li>
				<a href="https://www.linkedin.com/in/holgerwoltersdorf" title="Holger Woltersdorf on LinkedIn" target="_blank"><i class="fa fa-linkedin"></i></a>
			</li>
		</ul>

		<hr>

		<ul class="sidebar-nav">
			<li class="hidden-sm hidden-md hidden-lg">
				<a href="https://hollo.me/" title="Home">Home</a>
			</li>
			
						<li class="active">
		<a href="https://hollo.me/php.html">PHP</a>
					<ul class="nav">
															<li class="active">
		<a href="https://hollo.me/php/experimental-async-php-volume-2.html">Experimental async PHP - VOL. 2</a>
			</li>

											<li>
		<a href="https://hollo.me/php/experimental-async-php-volume-1.html">Experimental async PHP - VOL. 1</a>
			</li>

											<li>
		<a href="https://hollo.me/php/traitful-configs.html">&#039;Traitful&#039; configs</a>
			</li>

											<li>
		<a href="https://hollo.me/php/fluent-validation-with-ease.html">Fluent validation with ease</a>
			</li>

											<li>
		<a href="https://hollo.me/php/custom-exceptions-with-context.html">Custom exceptions with context</a>
			</li>

							</ul>
			</li>


			
						<li>
		<a href="https://hollo.me/talks.html">Talks</a>
			</li>


			
						<li>
		<a href="https://hollo.me/projects.html">Projects</a>
			</li>


			
						<li>
		<a href="https://hollo.me/devops.html">DevOps</a>
			</li>


			
						<li>
		<a href="https://hollo.me/reading-list.html">Reading list</a>
			</li>


			
						<li>
		<a href="https://hollo.me/imprint.html">Imprint</a>
			</li>


					</ul>

		<hr>

		<div class="text-center">
			<p>
				<small>Co-Founder of</small>
			</p>
			<a href="http://phpug-dresden.org" target="_blank">
				<img src="https://hollo.me/img/php-usergroup-dresden.png" alt="PHP USERGROUP DRESDEN e.V." class="img img-50">
			</a>
		</div>

		<hr>

		<p class="text-center website-version">
			<small>v1.0.0</small>
		</p>

	</div>

	<div id="breadcrumbs">
		<ul>
												<li>
						<a href="https://hollo.me/index.html">
							<i class="fa fa-map-marker"></i> Home
						</a>
					</li>
																<li>
						<a href="https://hollo.me/php.html">
							 PHP
						</a>
					</li>
																<li class="active">
						 Experimental async PHP - VOL. 2
					</li>
									</ul>
	</div>

	<div id="main">

		
			<h1>Experimental async PHP - Volume 2</h1>
			<h5>Second try to run a PHP daemon receiving messages from RabbtiMQ and executing commands async on the php-fpm socket</h5>

			<hr>

			<h2>Preamble</h2>
<p>Taking the topic of my <a href="https://hollo.me/php/experimental-async-php-volume-1.html">previous post</a> further, it is time to (hopefully) eliminate some drawbacks
that came along in the first try, such as:</p>
<ul>
<li>Redis has no message backlog. If the &quot;Daemon&quot; is not running for any reason, published messages will never be received.</li>
<li>Redis has a <a href="https://redis.io/commands/publish">publishing complexity</a> of &quot;<code>O(N+M)</code> where N is the number of clients subscribed to the receiving channel and M is the total number of subscribed patterns (by any client).&quot;
So all &quot;Daemons&quot; (if multiple) would get the same messages and trigger the same &quot;Workers&quot;. </li>
</ul>
<p>So let's change the goal a bit and replace Redis with a real message broker: <a href="https://www.rabbitmq.com">RabbitMQ</a>.</p>
<h2>Goal</h2>
<ul>
<li>A PHP script (&quot;Caller&quot;) sending messages to the RabbitMQ message queue system (&quot;Broker&quot;)</li>
<li>A PHP script (&quot;Daemon&quot;) running as a proper daemon consuming messages from the queue </li>
<li>On consuming a message the &quot;Daemon&quot; sends a new async request through php-fpm socket to the &quot;Worker&quot;</li>
<li>The php-fpm socket serves as an &quot;isolated&quot; pool and spawns child processes</li>
<li>The &quot;Workers&quot; process the requests in background </li>
</ul>
<hr />
<h2>Used environment</h2>
<ul>
<li>OS: Ubuntu Xenial 16.04.1 LTS</li>
<li>PHP 7.1.0-3+deb.sury.org~xenial+1</li>
<li><a href="https://www.rabbitmq.com/install-debian.html">RabbitMQ Server 3.6.6</a></li>
<li><a href="https://getcomposer.org">composer PHP dependency manager</a></li>
<li><i class="fa fa-github"></i> <a href="https://github.com/hollodotme/fast-cgi-client">hollodotme/fast-cgi-client</a></li>
<li><i class="fa fa-github"></i> <a href="https://github.com/php-amqplib/php-amqplib">php-amqplib/php-amqplib</a></li>
</ul>
<hr />
<h2>The &quot;Caller&quot; version #1</h2>
<p>Again, the &quot;Caller&quot; is a simple script, that sends a message to the &quot;Broker&quot;, to a queue named &quot;commands&quot;.
To be a little more verbose we'll provide a counter as an argument to the script that will be the content of the message.</p>
<p><i class="fa fa-file-o"></i> <code>src/caller.php</code></p>
<pre><code class="language-php">&lt;?php declare(strict_types = 1);

namespace hollodotme\AsyncPhp;

require(__DIR__ . '/../vendor/autoload.php');

use PhpAmqpLib\Connection\AMQPStreamConnection;
use PhpAmqpLib\Message\AMQPMessage;

# Connect and retrieve a channel
$connection = new AMQPStreamConnection( 'localhost', 5672, 'guest', 'guest' );
$channel    = $connection-&gt;channel();

# Make sure the queue 'commands' exist
$channel-&gt;queue_declare( 'commands' );

# Create and send the message
$message = new AMQPMessage( json_encode( [ 'number' =&gt; $argv[1] ], JSON_PRETTY_PRINT ) );
$channel-&gt;basic_publish( $message, '', 'commands' );

echo " [x] Message sent: {$argv[1]}\n";

# Close channel and connection
$channel-&gt;close();
$connection-&gt;close();</code></pre>
<hr />
<h2>The &quot;Daemon&quot; version #1</h2>
<p>Also in the &quot;Daemon&quot; we replace the Redis subscription with a basic consumption of messages sent to the &quot;commands&quot; queue of the &quot;Broker&quot;.</p>
<p>When a message is consumed a callback function (Closure) will be invoked.
This Closure will again send a request to our previously set up php-fpm pool, thus to our &quot;Workers&quot;.</p>
<p><i class="fa fa-file-o"></i> <code>src/daemon.php</code></p>
<pre><code class="language-php">&lt;?php declare(strict_types = 1);

namespace hollodotme\AsyncPhp;

use hollodotme\FastCGI\Client;
use hollodotme\FastCGI\SocketConnections\UnixDomainSocket;
use PhpAmqpLib\Connection\AMQPStreamConnection;
use PhpAmqpLib\Message\AMQPMessage;

require(__DIR__ . '/../vendor/autoload.php');

# Connect to the same RabbitMP instance and get a channel
$connection = new AMQPStreamConnection( 'localhost', 5672, 'guest', 'guest' );
$channel    = $connection-&gt;channel();

# Make sure the queue "commands" exists
$channel-&gt;queue_declare( 'commands' );

# Prepare the Fast CGI Client
$unixDomainSocket = new UnixDomainSocket( 'unix:///var/run/php/php7.1-fpm-commands.sock' );

# Define a callback function that is invoked whenever a message is consumed
$callback = function ( AMQPMessage $message ) use ( $unixDomainSocket )
{
    # Decode the json message and encode it for sending to php-fpm
    $messageArray = json_decode( $message-&gt;getBody(), true );
    $body         = http_build_query( $messageArray );

    # Send an async request to php-fpm pool and receive a process ID
    $fpmClient = new Client( $unixDomainSocket );
    $processId = $fpmClient-&gt;sendAsyncRequest(
        [
            'GATEWAY_INTERFACE' =&gt; 'FastCGI/1.0',
            'REQUEST_METHOD'    =&gt; 'POST',
            'SCRIPT_FILENAME'   =&gt; '/vagrant/src/worker.php',
            'SERVER_SOFTWARE'   =&gt; 'php/fcgiclient',
            'REMOTE_ADDR'       =&gt; '127.0.0.1',
            'REMOTE_PORT'       =&gt; '9985',
            'SERVER_ADDR'       =&gt; '127.0.0.1',
            'SERVER_PORT'       =&gt; '80',
            'SERVER_NAME'       =&gt; 'myServer',
            'SERVER_PROTOCOL'   =&gt; 'HTTP/1.1',
            'CONTENT_TYPE'      =&gt; 'application/x-www-form-urlencoded',
            'CONTENT_LENGTH'    =&gt; mb_strlen( $body ),
        ],
        $body
    );

    echo " [x] Spawned process with ID {$processId} for message number {$messageArray['number']}\n";
};

# Request consumption for queue "commands" using the defined callback function
$channel-&gt;basic_consume( 'commands', '', false, true, false, false, $callback );

# Wait to finish execution as long as the channel has callbacks
while ( count( $channel-&gt;callbacks ) )
{
    $channel-&gt;wait();
}</code></pre>
<p><strong>Note:</strong> You should not a use a persistent socket connection to php-fpm here, since you'll receive notices like this once in a while:
<code>PHP Notice:  fwrite(): send of 399 bytes failed with errno=11 Resource temporarily unavailable ...</code>. And a persistent connection will also cause the
php-fpm pool to spawn only one child worker, instead of as much as needed. </p>
<hr />
<h2>The &quot;Worker&quot;</h2>
<p>The worker remains the same for now. It simply logs the received number to a log file and sleeps for one second.</p>
<p><i class="fa fa-file-o"></i> <code>src/worker.php</code></p>
<pre><code class="language-php">&lt;?php declare(strict_types = 1);

namespace hollodotme\AsyncPhp;

require(__DIR__ . '/../vendor/autoload.php');

error_log( "Processing {$_POST['number']}\n", 3, sys_get_temp_dir() . '/workers.log' );

sleep( 1 );</code></pre>
<hr />
<h2>First test</h2>
<ol>
<li>(Re)start the &quot;Daemon&quot; and check if it's running properly:
<pre><code class="language-bash">sudo service php-daemon restart &amp;&amp; sudo service php-daemon status</code></pre></li>
<li>Watch the process list for spawning <code>php-fpm pool commands</code> (in a new terminal tab):
<pre><code class="language-bash">watch -n1 "sudo ps aux | grep 'php-fpm: pool commands' | grep -v grep"</code></pre></li>
<li>Watch the <code>logs/worker.log</code> (in a new terminal tab):
<pre><code class="language-bash">tailf "cat /tmp/workers.log"</code></pre></li>
<li>Watch the syslog for spawned process by &quot;Daemon&quot; (in a new terminal tab):
<pre><code class="language-bash">tailf /var/log/syslog | grep '\[x\]'</code></pre></li>
<li>Execute the &quot;Caller&quot; 100 times:
<pre><code class="language-bash">for i in $(seq 1 100); do php7.1 src/caller.php $i; done</code></pre></li>
</ol>
<p><strong>Results:</strong></p>
<video width="100%" controls><source src="https://hollo.me/video/php/ExperimentalAsyncPHPvol2-1.mp4" type="video/mp4">
Your browser does not support the video tag.
</source></video>
<hr />
<p>This result is already pretty much what we want, but there are still some &quot;hidden&quot; drawbacks:</p>
<ol>
<li>
<p><strong>The message queue consumption</strong><br />
While the test above runs a glimpse at the RabbitMQ queue list (<code>rabbitmqctl list_queues</code>) shows that there is a queue named &quot;commands&quot; with &quot;0&quot; outstanding messages.
This is because our messages are not persistent and are immediately delivered to the consumer, that connects first.
This is not what we want if we want to scale to multiple &quot;Daemons&quot;. Currently there is no &quot;distribution plan&quot; for messages for multiple &quot;Daemons&quot;.  </p>
</li>
<li><strong>&quot;Daemons&quot; gonna die!</strong><br />
Occasionally consumers of messages happen to die for whatever reason. Since our messages are not persistent yet, they will be deleted from the
queue as soon as they were sent to the &quot;Daemon&quot;, regardless if they were fully processed or not.</li>
</ol>
<hr />
<h2>Persist and acknowledge</h2>
<p>To eliminate the before mentioned drawbacks we should slightly change the usage of RabbitMQ to have work queues (task queues) with persistent messages
instead of volatile messages. So if messages are persistent, we also need to tell the channel when a message (task) was fully processed and can be deleted from the queue.
Thus we'll send an acknowledgement back to the channel.</p>
<h3>The &quot;Caller&quot; version #2</h3>
<p><i class="fa fa-file-o"></i> <code>src/caller.php</code></p>
<pre><code class="language-php">&lt;?php declare(strict_types = 1);

namespace hollodotme\AsyncPhp;

require(__DIR__ . '/../vendor/autoload.php');

use PhpAmqpLib\Connection\AMQPStreamConnection;
use PhpAmqpLib\Message\AMQPMessage;

# Connect and retrieve a channel
$connection = new AMQPStreamConnection( 'localhost', 5672, 'guest', 'guest' );
$channel    = $connection-&gt;channel();

# Make sure the queue 'commands' exist
$channel-&gt;queue_declare( 'commands' );

# Create and send the message
$message = new AMQPMessage(
    json_encode( [ 'number' =&gt; $argv[1] ], JSON_PRETTY_PRINT ),

    # Make the messages persistent
    [
        'delivery_mode' =&gt; AMQPMessage::DELIVERY_MODE_PERSISTENT,
    ]
);
$channel-&gt;basic_publish( $message, '', 'commands' );

echo " [x] Message sent: {$argv[1]}\n";

# Close channel and connection
$channel-&gt;close();
$connection-&gt;close();</code></pre>
<p>As you can see, we added an options array telling the message to be in persistent delivery mode.</p>
<hr />
<h3>The &quot;Daemon&quot; version #2</h3>
<p><i class="fa fa-file-o"></i> <code>src/daemon.php</code></p>
<pre><code class="language-php">&lt;?php declare(strict_types = 1);

namespace hollodotme\AsyncPhp;

use hollodotme\FastCGI\Client;
use hollodotme\FastCGI\SocketConnections\UnixDomainSocket;
use PhpAmqpLib\Connection\AMQPStreamConnection;
use PhpAmqpLib\Message\AMQPMessage;

require(__DIR__ . '/../vendor/autoload.php');

# Connect to the same RabbitMP instance and get a channel
$connection = new AMQPStreamConnection( 'localhost', 5672, 'guest', 'guest' );
$channel    = $connection-&gt;channel();

# Make sure the queue "commands" exists
$channel-&gt;queue_declare( 'commands' );

# Prepare the Fast CGI Client
$unixDomainSocket = new UnixDomainSocket( 'unix:///var/run/php/php7.1-fpm-commands.sock' );

# Define a callback function that is invoked whenever a message is consumed
$callback = function ( AMQPMessage $message ) use ( $unixDomainSocket )
{
    # Decode the json message and encode it for sending to php-fpm
    $messageArray = json_decode( $message-&gt;getBody(), true );
    $messageArray['daemon'] = mt_rand( 1, 100);
    $body         = http_build_query( $messageArray );

    # Send an async request to php-fpm pool and receive a process ID
    $fpmClient = new Client( $unixDomainSocket );
    $processId = $fpmClient-&gt;sendAsyncRequest(
        [
            'GATEWAY_INTERFACE' =&gt; 'FastCGI/1.0',
            'REQUEST_METHOD'    =&gt; 'POST',
            'SCRIPT_FILENAME'   =&gt; '/vagrant/src/worker.php',
            'SERVER_SOFTWARE'   =&gt; 'php/fcgiclient',
            'REMOTE_ADDR'       =&gt; '127.0.0.1',
            'REMOTE_PORT'       =&gt; '9985',
            'SERVER_ADDR'       =&gt; '127.0.0.1',
            'SERVER_PORT'       =&gt; '80',
            'SERVER_NAME'       =&gt; 'myServer',
            'SERVER_PROTOCOL'   =&gt; 'HTTP/1.1',
            'CONTENT_TYPE'      =&gt; 'application/x-www-form-urlencoded',
            'CONTENT_LENGTH'    =&gt; mb_strlen( $body ),
        ],
        $body
    );

    echo " [x] Spawned process with ID {$processId} for message number {$messageArray['number']}\n";

    # Send the ACK(nowledgement) back to the channel for this particular message
    $message-&gt;get( 'channel' )-&gt;basic_ack( $message-&gt;get( 'delivery_tag' ) );
};

# Set the prefetch count to 1 for this consumer
$channel-&gt;basic_qos( null, 1, null );

# Request consumption for queue "commands" using the defined callback function
# Enable message acknowledgement (set 4th parameter to false)
$channel-&gt;basic_consume( 'commands', '', false, false, false, false, $callback );

# Wait to finish execution as long as the channel has callbacks
while ( count( $channel-&gt;callbacks ) )
{
    $channel-&gt;wait();
}</code></pre>
<p>What has changed?</p>
<ul>
<li>
<p>We set the <a href="http://www.rabbitmq.com/consumer-prefetch.html">prefetch count</a> for this consumer to <code>1</code>:</p>
<pre><code class="language-php">$channel-&gt;basic_qos( null, 1, null );</code></pre>
</li>
<li>
<p>We enabled message acknowledgement:</p>
<pre><code class="language-php"># 4th parameter set to false
$channel-&gt;basic_consume( 'commands', '', false, false, false, false, $callback );</code></pre>
</li>
<li>We send an ACK(nowledge) back to the channel as soon as we spawned our &quot;Worker&quot;:
<pre><code class="language-php">$message-&gt;get( 'channel' )-&gt;basic_ack( $message-&gt;get( 'delivery_tag' ) );</code></pre></li>
</ul>

		
	</div>
</div>
<script src="https://hollo.me/js/theme.js"></script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.9.0/styles/default.min.css">
<script src="//cdn.jsdelivr.net/highlight.js/9.9.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
